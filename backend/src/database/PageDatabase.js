/**
 * PageDatabase - Manages page/screen storage
 * Stores pages generated by PageExpert
 */

const fs = require('fs');
const path = require('path');

class PageDatabase {
  constructor() {
    this.dbPath = path.join(__dirname, '../../data/pages.json');
    this.ensureDataDirectory();
    this.pages = this.loadPages();
  }

  ensureDataDirectory() {
    const dataDir = path.dirname(this.dbPath);
    if (!fs.existsSync(dataDir)) {
      fs.mkdirSync(dataDir, { recursive: true });
    }
    if (!fs.existsSync(this.dbPath)) {
      fs.writeFileSync(this.dbPath, JSON.stringify([], null, 2));
    }
  }

  loadPages() {
    try {
      if (fs.existsSync(this.dbPath)) {
        const data = fs.readFileSync(this.dbPath, 'utf8');
        return JSON.parse(data);
      }
    } catch (error) {
      console.error('[PageDatabase] Error loading pages:', error);
    }
    return [];
  }

  savePages(pages) {
    try {
      const existingPages = this.loadPages();
      const updatedPages = [...existingPages];

      pages.forEach(page => {
        const index = updatedPages.findIndex(p => p.id === page.id);
        if (index >= 0) {
          // Update existing page
          updatedPages[index] = {
            ...updatedPages[index],
            ...page,
            updatedAt: new Date().toISOString()
          };
        } else {
          // Add new page
          updatedPages.push({
            ...page,
            createdAt: new Date().toISOString()
          });
        }
      });

      fs.writeFileSync(this.dbPath, JSON.stringify(updatedPages, null, 2));
      this.pages = updatedPages;

      console.log(`[PageDatabase] Saved ${pages.length} pages to database`);
      return updatedPages;
    } catch (error) {
      console.error('[PageDatabase] Error saving pages:', error);
      throw error;
    }
  }

  getAllPages() {
    return this.loadPages();
  }

  getPageById(pageId) {
    const pages = this.loadPages();
    return pages.find(p => p.id === pageId);
  }

  getPagesByWorkflow(workflowId) {
    const pages = this.loadPages();
    return pages.filter(p => p.metadata?.workflowId === workflowId);
  }

  getPagesByType(type) {
    const pages = this.loadPages();
    return pages.filter(p => p.type === type);
  }

  getPagesByPlatform(platform) {
    const pages = this.loadPages();
    return pages.filter(p => p.platform === platform || p.platform === 'both');
  }

  getPagesByEntity(entityName) {
    const pages = this.loadPages();
    return pages.filter(p => p.metadata?.entity === entityName);
  }

  deletePage(pageId) {
    try {
      const pages = this.loadPages();
      const filtered = pages.filter(p => p.id !== pageId);
      fs.writeFileSync(this.dbPath, JSON.stringify(filtered, null, 2));
      this.pages = filtered;
      console.log(`[PageDatabase] Deleted page: ${pageId}`);
      return true;
    } catch (error) {
      console.error('[PageDatabase] Error deleting page:', error);
      throw error;
    }
  }

  clearAll() {
    try {
      fs.writeFileSync(this.dbPath, JSON.stringify([], null, 2));
      this.pages = [];
      console.log('[PageDatabase] Cleared all pages');
      return true;
    } catch (error) {
      console.error('[PageDatabase] Error clearing pages:', error);
      throw error;
    }
  }

  getStats() {
    const pages = this.loadPages();
    const stats = {
      total: pages.length,
      byType: {},
      byPlatform: {},
      byEntity: {}
    };

    pages.forEach(page => {
      // Count by type
      stats.byType[page.type] = (stats.byType[page.type] || 0) + 1;

      // Count by platform
      stats.byPlatform[page.platform] = (stats.byPlatform[page.platform] || 0) + 1;

      // Count by entity
      if (page.metadata?.entity) {
        stats.byEntity[page.metadata.entity] = (stats.byEntity[page.metadata.entity] || 0) + 1;
      }
    });

    return stats;
  }
}

module.exports = new PageDatabase();
